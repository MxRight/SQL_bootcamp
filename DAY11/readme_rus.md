## 

## Задание 00 — Классическое DWH

| Задание 00: Классическое DWH |                   |
| ---------------------------- | ----------------- |
| Папка для сдачи работы       | ex00              |
| Файлы для сдачи              | `team01_ex00.sql` |
| **Разрешено**                |                   |
| Язык                         | SQL               |



### Определение таблицы `User` (в *Зелёной* источниковой базе данных):

| Имя колонки | Описание             |
| ----------- | -------------------- |
| ID          | Первичный ключ       |
| name        | Имя пользователя     |
| lastname    | Фамилия пользователя |

---

### Определение таблицы `Currency` (в *Красной* источниковой базе данных):

| Имя колонки | Описание                |
| ----------- | ----------------------- |
| ID          | Первичный ключ          |
| name        | Название валюты         |
| rate_to_usd | Курс по отношению к USD |

---

### Определение таблицы `Balance` (в *Синей* источниковой базе данных):

| Имя колонки | Описание                                                             |
| ----------- | -------------------------------------------------------------------- |
| user_id     | «Виртуальный внешний ключ» к таблице `User` из другого источника     |
| money       | Сумма денег                                                          |
| type        | Тип баланса (может быть 0,1,...)                                     |
| currency_id | «Виртуальный внешний ключ» к таблице `Currency` из другого источника |

Зелёная, красная и синяя базы данных являются независимыми источниками данных и соответствуют паттерну микросервисов. Это означает, что есть высокий риск появления аномалий данных:  

- Таблицы не находятся в **согласованности**. Например, есть пользователь, но нет соответствующих записей в `Balance`, или наоборот, есть записи в `Balance`, но нет такого пользователя в таблице `User`. Такая же ситуация возможна между таблицами `Currency` и `Balance`. (Другими словами, явных внешних ключей между ними нет).  
- Возможные значения `NULL` для `Name` и `Lastname` в таблице `User`.  
- Все таблицы работают в режиме **OLTP** (OnLine Transactional Processing). Это значит, что хранится только актуальное состояние данных в момент времени, а исторические изменения не сохраняются.  

Эти три таблицы являются источниками данных для таблиц с аналогичной моделью в области DWH.  

---

### Определение таблицы `User` (в *базе данных DWH*):

| Имя колонки | Описание             |
| ----------- | -------------------- |
| ID          | Первичный ключ       |
| name        | Имя пользователя     |
| lastname    | Фамилия пользователя |

---

### Определение таблицы `Currency` (в *базе данных DWH*):

| Имя колонки | Описание                                            |
| ----------- | --------------------------------------------------- |
| ID          | «Моковый» первичный ключ                            |
| name        | Название валюты                                     |
| rate_to_usd | Курс по отношению к USD                             |
| updated     | Временная метка события из источниковой базы данных |

**Примечание:** «Моковый первичный ключ» означает, что появляются дубликаты с тем же `ID`, потому что добавлен новый атрибут `updated`. Это меняет модель на **временную реляционную модель (Temporal Relational Model)**.  

#### Пример данных для валюты EUR:

```sql
SELECT *
FROM Currency
WHERE name = 'EUR'
ORDER BY updated DESC;
```

| ID  | name | rate_to_usd | updated          |
| --- | ---- | ----------- | ---------------- |
| 100 | EUR  | 0.9         | 03.03.2022 13:31 |
| 100 | EUR  | 0.89        | 02.03.2022 12:31 |
| 100 | EUR  | 0.87        | 02.03.2022 08:00 |
| 100 | EUR  | 0.9         | 01.03.2022 15:36 |
| ... | ...  | ...         | ...              |

---

### Определение таблицы `Balance` (в *базе данных DWH*):

| Имя колонки | Описание                                                             |
| ----------- | -------------------------------------------------------------------- |
| user_id     | «Виртуальный внешний ключ» к таблице `User` из другого источника     |
| money       | Сумма денег                                                          |
| type        | Тип баланса (0, 1, …)                                                |
| currency_id | «Виртуальный внешний ключ» к таблице `Currency` из другого источника |
| updated     | Временная метка события из источниковой базы данных                  |

#### Пример данных:

```sql
SELECT *
FROM Balance
WHERE user_id = 103
ORDER BY type, updated DESC;
```

| user_id | money | type | currency_id | updated          |
| ------- | ----- | ---- | ----------- | ---------------- |
| 103     | 200   | 0    | 100         | 03.03.2022 12:31 |
| 103     | 150   | 0    | 100         | 02.03.2022 11:29 |
| 103     | 15    | 0    | 100         | 03.03.2022 08:00 |
| 103     | -100  | 1    | 102         | 01.03.2022 15:36 |
| 103     | 2000  | 1    | 102         | 12.12.2021 15:36 |
| ...     | ...   | ...  | ...         | ...              |

---

Все таблицы в DWH наследуют **аномалии** из источниковых таблиц:  

- Таблицы не находятся в согласованности.  
- Возможные `NULL` значения для `Name` и `Lastname` в таблице `User`.  

---

### Задача:

Напишите SQL-запрос, который возвращает **общий объём (сумму всех денег)** транзакций из баланса пользователей, агрегированных по пользователю и типу баланса.  
При этом все данные должны быть обработаны, включая данные с аномалиями.   

**Формулы для расчёта выходных колонок:**  

| Выходная колонка    | Расчёт (псевдокод)                                                                         |
| ------------------- | ------------------------------------------------------------------------------------------ |
| name                | источник: user.name; если `NULL` → вернуть `'not defined'`                                 |
| lastname            | источник: user.lastname; если `NULL` → вернуть `'not defined'`                             |
| type                | источник: balance.type                                                                     |
| volume              | источник: сумма значений balance.money                                                     |
| currency_name       | источник: currency.name; если `NULL` → вернуть `'not defined'`                             |
| last_rate_to_usd    | источник: currency.rate_to_usd. Взять последний курс для валюты. Если `NULL` → вернуть `1` |
| total_volume_in_usd | источник: volume × last_rate_to_usd                                                        |

#### Пример результатов (отсортировать по имени пользователя по убыванию, затем по фамилии и типу — по возрастанию):

| name | lastname    | type | volume | currency_name | last_rate_to_usd | total_volume_in_usd |
| ---- | ----------- | ---- | ------ | ------------- | ---------------- | ------------------- |
| Петр | not defined | 2    | 203    | not defined   | 1                | 203                 |
| Иван | Иванов      | 1    | 410    | EUR           | 0.9              | 369                 |
| ...  | ...         | ...  | ...    | ...           | ...              | ...                 |

---

## Задание 01 — Детализированный запрос

| Задание 01: Детализированный запрос |                   |
| ----------------------------------- | ----------------- |
| Папка для сдачи работы              | ex01              |
| Файлы для сдачи                     | `team01_ex01.sql` |
| **Разрешено**                       |                   |
| Язык                                | ANSI SQL          |

Перед тем как начать, выполните следующие команды:  

```sql
insert into currency values (100, 'EUR', 0.85, '2022-01-01 13:29');
insert into currency values (100, 'EUR', 0.79, '2022-01-08 13:29');
```

---

### Задача

Напишите SQL-запрос, который возвращает **всех пользователей**, все записи из `Balance` (в этом задании нужно **игнорировать валюты**, которых нет в таблице `Currency`), *вместе с названием валюты* и **значением валюты в USD на следующий день**.  

**Формулы для расчёта выходных колонок:**  

| Выходная колонка | Расчёт (псевдокод)                                                  |
| ---------------- | ------------------------------------------------------------------- |
| name             | источник: user.name; если NULL → `not defined`                      |
| lastname         | источник: user.lastname; если NULL → `not defined`                  |
| currency_name    | источник: currency.name                                             |
| currency_in_usd  | источники: currency.rate_to_usd, currency.updated, balance.updated. |

Графическая интерпретация формулы:  

![T01_06](misc/images/T01_06.png)

- Найдите ближайший `rate_to_usd` валюты в прошлом (t1).  
- Если t1 пуст — найдите ближайший `rate_to_usd` в будущем (t2).  
- Используйте курс из t1 ИЛИ t2 для вычисления значения в USD.  

---

### Пример выходных данных (отсортировать по имени пользователя по убыванию, затем по фамилии и названию валюты по возрастанию):

| name | lastname | currency_name | currency_in_usd |
| ---- | -------- | ------------- | --------------- |
| Иван | Иванов   | EUR           | 150.1           |
| Иван | Иванов   | EUR           | 17              |
| ...  | ...      | ...           | ...             |

---