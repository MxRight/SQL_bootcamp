

## Упражнение 00 — Скидки, скидки, все любят скидки

| Упражнение 00: Скидки, скидки, все любят скидки |                  |
| ----------------------------------------------- | ---------------- |
| Директория для сдачи                            | ex00             |
| Файлы для сдачи                                 | `day06_ex00.sql` |
| **Разрешено**                                   |                  |
| Языки                                           | SQL, DML, DDL    |

Добавим новую бизнес-функцию в нашу модель данных.  
Каждый человек хочет видеть **персональную скидку**, а каждый бизнес хочет быть ближе к клиентам.  

Подумайте о скидках: с одной стороны — для людей, а с другой — для пиццерий. Нужно создать **новую реляционную таблицу** (название `person_discounts`) со следующими правилами:  

- Поле `id` должно быть **Primary Key** (возьмите тот же тип данных, что и в других таблицах).  
- Атрибуты `person_id` и `pizzeria_id` должны быть внешними ключами, которые ссылаются на соответствующие таблицы (`person` и `pizzeria`), и использовать те же типы данных, что и `id` в родительских таблицах.  
- Задайте **явные имена** для ограничений внешних ключей по шаблону: `fk_{имя_таблицы}_{имя_колонки}`, например: `fk_person_discounts_person_id`.  
- Добавьте атрибут `discount` для хранения значения скидки в процентах. Скидка может быть дробным числом, поэтому выберите соответствующий тип данных (например, `numeric`).  

---

## Упражнение 01 — Назначим персональные скидки

| Упражнение 01: Назначим персональные скидки |                  |
| ------------------------------------------- | ---------------- |
| Директория для сдачи                        | ex01             |
| Файлы для сдачи                             | `day06_ex01.sql` |
| **Разрешено**                               |                  |
| Языки                                       | SQL, DML, DDL    |

Теперь у нас есть структура для хранения скидок, и можно её заполнить.  

У нас есть таблица `person_order`, где хранится история заказов клиентов. Нужно написать SQL-запрос (`INSERT INTO ... SELECT ...`), который будет вставлять данные в таблицу `person_discounts` по следующим правилам:

- Брать в выборку комбинацию `person_id` и `pizzeria_id`.  
- Рассчитывать значение скидки по псевдокоду:  

```
if "кол-во заказов" = 1 then
    "скидка" = 10.5
else if "кол-во заказов" = 2 then
    "скидка" = 22
else
    "скидка" = 30
```

- Для генерации Primary Key в `person_discounts` используйте конструкцию с оконной функцией:  

```sql
... ROW_NUMBER() OVER () AS id ...
```

---

## Упражнение 02 — Пересчитаем историю заказов

| Упражнение 02: Пересчитаем историю заказов |                  |
| ------------------------------------------ | ---------------- |
| Директория для сдачи                       | ex02             |
| Файлы для сдачи                            | `day06_ex02.sql` |
| **Разрешено**                              |                  |
| Языки                                      | SQL, DML, DDL    |

Напишите SQL-запрос, который возвращает заказы со **своей ценой** и **ценой с учётом скидки** для каждого клиента в соответствующей пиццерии.  
Данные нужно отсортировать по имени клиента и названию пиццы.  

**Пример результата:**  

| name   | pizza_name    | price | discount_price | pizzeria_name |
| ------ | ------------- | ----- | -------------- | ------------- |
| Андрей | сырная пицца  | 800   | 624            | Dominos       |
| Андрей | грибная пицца | 1100  | 858            | Dominos       |
| …      | …             | …     | …              | …             |

---

## Упражнение 03 — Улучшения на подходе

| Упражнение 03: Улучшения на подходе |                  |
| ----------------------------------- | ---------------- |
| Директория для сдачи                | ex03             |
| Файлы для сдачи                     | `day06_ex03.sql` |
| **Разрешено**                       |                  |
| Языки                               | SQL, DML, DDL    |

Нужно повысить целостность данных и оптимизировать производительность.  
Создайте **многоколонковый уникальный индекс** (`idx_person_discounts_unique`), который запретит дубликаты пар (`person_id`, `pizzeria_id`).  

После создания индекса предоставьте любой простой SQL-запрос с `EXPLAIN ANALYZE`, который докажет, что используется **индексный поиск**.  

**Пример доказательства:**  

```
...
Index Scan using idx_person_discounts_unique on person_discounts
...
```

---

## Упражнение 04 — Нужна больше целостность данных

| Упражнение 04: Нужна больше целостность данных |                  |
| ---------------------------------------------- | ---------------- |
| Директория для сдачи                           | ex04             |
| Файлы для сдачи                                | `day06_ex04.sql` |
| **Разрешено**                                  |                  |
| Языки                                          | SQL, DML, DDL    |

Добавьте следующие ограничения (**constraints**) для таблицы `person_discounts`:  

- `person_id` **НЕ NULL** (имя ограничения `ch_nn_person_id`).  
- `pizzeria_id` **НЕ NULL** (имя ограничения `ch_nn_pizzeria_id`).  
- `discount` **НЕ NULL** (имя ограничения `ch_nn_discount`).  
- Значение `discount` по умолчанию должно быть **0**.  
- Значение `discount` должно быть в диапазоне от 0 до 100 (имя ограничения `ch_range_discount`).  

---

## Упражнение 05 — Правила Data Governance

| Упражнение 05: Правила Data Governance |                  |
| -------------------------------------- | ---------------- |
| Директория для сдачи                   | ex05             |
| Файлы для сдачи                        | `day06_ex05.sql` |
| **Разрешено**                          |                  |
| Языки                                  | SQL, DML, DDL    |

Чтобы соответствовать правилам **управления данными (Data Governance)**, необходимо добавить комментарии для таблицы и её колонок.  

Примените это к `person_discounts`: добавьте пояснительные комментарии (на русском или английском), объясняющие **бизнес-цель таблицы** и назначение всех её атрибутов.  

---

## Упражнение 06 — Автоматизируем генерацию Primary Key

| Упражнение 06: Автоматизируем генерацию Primary Key |                                                                                                                 |
| --------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| Директория для сдачи                                | ex06                                                                                                            |
| Файлы для сдачи                                     | `day06_ex06.sql`                                                                                                |
| **Разрешено**                                       |                                                                                                                 |
| Языки                                               | SQL, DML, DDL                                                                                                   |
| **Запрещено**                                       |                                                                                                                 |
| SQL-синтаксис                                       | Использовать «жёстко захардкоженное значение» для количества строк при настройке последовательности (sequence). |

Нужно создать **последовательность (SEQUENCE)** с именем `seq_person_discounts` (начало с 1) и назначить её как **значение по умолчанию** для поля `id` таблицы `person_discounts`.  

При этом важно:  

- Следующее значение в последовательности должно равняться `количество строк в таблице person_discounts + 1`.  
- В противном случае вы получите ошибку нарушения Primary Key.  
